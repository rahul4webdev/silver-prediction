"""
Notification service for sending alerts via Telegram, email, etc.
Sends prediction alerts, price alerts, and model performance notifications.
"""

import asyncio
import logging
from datetime import datetime
from typing import Any, Dict, List, Optional

import aiohttp

from app.core.config import settings

logger = logging.getLogger(__name__)


class TelegramNotificationService:
    """
    Telegram notification service for sending alerts.

    Supports:
    - Prediction alerts (new predictions)
    - Price alerts (target price reached)
    - Verification alerts (prediction results)
    - High-confidence signals
    - Daily summaries
    """

    def __init__(
        self,
        bot_token: Optional[str] = None,
        chat_id: Optional[str] = None,
    ):
        self.bot_token = bot_token or settings.telegram_bot_token
        self.chat_id = chat_id or settings.telegram_chat_id
        self.base_url = f"https://api.telegram.org/bot{self.bot_token}" if self.bot_token else None

    @property
    def is_configured(self) -> bool:
        """Check if Telegram is properly configured."""
        return bool(self.bot_token and self.chat_id)

    async def send_message(
        self,
        message: str,
        parse_mode: str = "HTML",
        disable_notification: bool = False,
    ) -> bool:
        """
        Send a message via Telegram.

        Args:
            message: Message text (supports HTML formatting)
            parse_mode: 'HTML' or 'Markdown'
            disable_notification: If True, sends silently

        Returns:
            True if successful, False otherwise
        """
        if not self.is_configured:
            logger.warning("Telegram not configured, skipping notification")
            return False

        try:
            url = f"{self.base_url}/sendMessage"
            payload = {
                "chat_id": self.chat_id,
                "text": message,
                "parse_mode": parse_mode,
                "disable_notification": disable_notification,
            }

            async with aiohttp.ClientSession() as session:
                async with session.post(url, json=payload, timeout=10) as response:
                    if response.status == 200:
                        logger.info("Telegram message sent successfully")
                        return True
                    else:
                        error = await response.text()
                        logger.error(f"Telegram error: {response.status} - {error}")
                        return False

        except Exception as e:
            logger.error(f"Failed to send Telegram message: {e}")
            return False

    async def send_prediction_alert(
        self,
        prediction: Dict[str, Any],
        high_confidence: bool = False,
    ) -> bool:
        """
        Send a new prediction alert.

        Args:
            prediction: Prediction data dict
            high_confidence: If True, marks as high confidence signal

        Returns:
            True if successful
        """
        direction = prediction.get("predicted_direction", "unknown")
        direction_emoji = "üìà" if direction == "bullish" else "üìâ" if direction == "bearish" else "‚û°Ô∏è"
        confidence = prediction.get("direction_confidence", 0)

        # Format confidence intervals
        ci_80 = prediction.get("confidence_intervals", {}).get("ci_80", {})
        ci_lower = ci_80.get("lower", 0)
        ci_upper = ci_80.get("upper", 0)

        # Build message
        header = "üîî <b>HIGH CONFIDENCE SIGNAL</b>" if high_confidence else "üîÆ <b>New Prediction</b>"

        message = f"""
{header}

{direction_emoji} <b>{prediction.get('asset', 'Silver').upper()}</b> - {prediction.get('market', '').upper()}
<b>Interval:</b> {prediction.get('interval', '')}

<b>Direction:</b> {direction.upper()}
<b>Confidence:</b> {confidence:.1%}

<b>Current Price:</b> ‚Çπ{prediction.get('current_price', 0):,.2f}
<b>Predicted:</b> ‚Çπ{prediction.get('predicted_price', 0):,.2f}
<b>80% Range:</b> ‚Çπ{ci_lower:,.2f} - ‚Çπ{ci_upper:,.2f}

<b>Target Time:</b> {prediction.get('target_time', '')[:16]}

<i>Generated by Silver Prediction System</i>
"""
        return await self.send_message(message.strip())

    async def send_verification_alert(
        self,
        prediction: Dict[str, Any],
        actual_price: float,
        was_correct: bool,
    ) -> bool:
        """
        Send a prediction verification alert.

        Args:
            prediction: Original prediction data
            actual_price: Actual price at target time
            was_correct: Whether direction was correct

        Returns:
            True if successful
        """
        status_emoji = "‚úÖ" if was_correct else "‚ùå"
        predicted_direction = prediction.get("predicted_direction", "unknown")

        # Calculate error
        predicted_price = prediction.get("predicted_price", 0)
        error_pct = ((actual_price - predicted_price) / predicted_price * 100) if predicted_price else 0

        message = f"""
{status_emoji} <b>Prediction Result</b>

<b>{prediction.get('asset', 'Silver').upper()}</b> - {prediction.get('market', '').upper()}
<b>Interval:</b> {prediction.get('interval', '')}

<b>Predicted:</b> {predicted_direction.upper()}
<b>Result:</b> {'CORRECT' if was_correct else 'WRONG'}

<b>Predicted Price:</b> ‚Çπ{predicted_price:,.2f}
<b>Actual Price:</b> ‚Çπ{actual_price:,.2f}
<b>Error:</b> {error_pct:+.2f}%

<i>Track accuracy at /accuracy</i>
"""
        return await self.send_message(message.strip())

    async def send_price_alert(
        self,
        asset: str,
        market: str,
        current_price: float,
        alert_price: float,
        alert_type: str,  # 'above' or 'below'
    ) -> bool:
        """
        Send a price alert when target is reached.

        Args:
            asset: Asset name
            market: Market (mcx/comex)
            current_price: Current price
            alert_price: Alert trigger price
            alert_type: 'above' or 'below'

        Returns:
            True if successful
        """
        emoji = "üî∫" if alert_type == "above" else "üîª"

        message = f"""
{emoji} <b>Price Alert Triggered!</b>

<b>{asset.upper()}</b> - {market.upper()}

<b>Alert:</b> Price {'above' if alert_type == 'above' else 'below'} ‚Çπ{alert_price:,.2f}
<b>Current:</b> ‚Çπ{current_price:,.2f}

<i>Set at {datetime.now().strftime('%H:%M:%S')}</i>
"""
        return await self.send_message(message.strip())

    async def send_confluence_signal(
        self,
        asset: str,
        market: str,
        aligned_intervals: List[str],
        direction: str,
        avg_confidence: float,
    ) -> bool:
        """
        Send alert when multiple timeframes align.

        Args:
            asset: Asset name
            market: Market
            aligned_intervals: List of aligned intervals
            direction: Common direction
            avg_confidence: Average confidence

        Returns:
            True if successful
        """
        direction_emoji = "üìà" if direction == "bullish" else "üìâ"

        message = f"""
üéØ <b>CONFLUENCE SIGNAL</b>

{direction_emoji} <b>{asset.upper()}</b> - {market.upper()}

<b>All {len(aligned_intervals)} timeframes aligned!</b>
<b>Intervals:</b> {', '.join(aligned_intervals)}
<b>Direction:</b> {direction.upper()}
<b>Avg Confidence:</b> {avg_confidence:.1%}

<i>Multi-timeframe confluence increases signal strength</i>
"""
        return await self.send_message(message.strip())

    async def send_daily_summary(
        self,
        summary: Dict[str, Any],
    ) -> bool:
        """
        Send daily performance summary.

        Args:
            summary: Daily summary data

        Returns:
            True if successful
        """
        total = summary.get("total_predictions", 0)
        correct = summary.get("correct_predictions", 0)
        accuracy = (correct / total * 100) if total > 0 else 0

        message = f"""
üìä <b>Daily Summary</b>
<b>Date:</b> {datetime.now().strftime('%Y-%m-%d')}

<b>Total Predictions:</b> {total}
<b>Correct:</b> {correct}
<b>Accuracy:</b> {accuracy:.1f}%

<b>By Market:</b>
MCX: {summary.get('mcx_accuracy', 0):.1f}%
COMEX: {summary.get('comex_accuracy', 0):.1f}%

<b>Current Streak:</b> {summary.get('streak', 0)} {'wins' if summary.get('streak', 0) > 0 else 'losses'}

<i>View detailed analytics at /accuracy</i>
"""
        return await self.send_message(message.strip())

    async def send_model_retrain_notification(
        self,
        results: Dict[str, Any],
    ) -> bool:
        """
        Send notification when models are retrained.

        Args:
            results: Training results

        Returns:
            True if successful
        """
        message = f"""
üîÑ <b>Models Retrained</b>

<b>Training Completed:</b> {datetime.now().strftime('%Y-%m-%d %H:%M')}
<b>Samples Used:</b> {results.get('training_samples', 0):,}

<b>Model Weights Updated:</b>
{self._format_weights(results.get('model_weights', {}))}

<i>Models ready for predictions</i>
"""
        return await self.send_message(message.strip())

    def _format_weights(self, weights: Dict[str, float]) -> str:
        """Format model weights for display."""
        lines = []
        for model, weight in sorted(weights.items(), key=lambda x: x[1], reverse=True):
            bar_len = int(weight * 20)
            bar = "‚ñà" * bar_len + "‚ñë" * (20 - bar_len)
            lines.append(f"{model}: {bar} {weight:.1%}")
        return "\n".join(lines)


# Singleton instance
telegram_service = TelegramNotificationService()
